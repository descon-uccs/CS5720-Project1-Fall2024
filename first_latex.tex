\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{float}

\title{Empirical Analysis of Brute-Force Search Algorithm}
\author{Your Name}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}
The purpose of this project is to empirically analyze the time complexity of a brute-force search algorithm in terms of its worst-case, best-case, and average-case performance. The analysis is conducted using various sizes of character arrays derived from an English text and the algorithm is tested for different search characters (`e`, `m`, `Q`, and `%`). We provide insights into the runtime of the algorithm and conjecture about the algorithmâ€™s complexity based on the empirical results.

\section{Methodology}

\subsection{Search Algorithm}
We implemented a brute-force search algorithm that takes a character array \( A[n] \) and a search key \( K \). The algorithm returns the lowest index in \( A \) where \( K \) appears or \( n \) if \( K \) is not found. 

\begin{verbatim}
# Brute-force search algorithm
def search_algorithm(arr, key):
    for i in range(len(arr)):
        if arr[i] == key:
            return i
    return len(arr)
\end{verbatim}

\subsection{Dataset Generation}
To generate datasets for the empirical analysis, we used a public domain English text (``Pride and Prejudice'' by Jane Austen) downloaded from Project Gutenberg. The text was cleaned and split into character arrays of varying lengths (1000, 2000, ..., 10000). For each array length \( n \), 50 arrays were generated.

\subsection{Runtime Analysis}
We ran the search algorithm on the generated datasets for the characters `e`, `m`, `Q`, and `%`. For each test character and array size, we measured the worst-case, best-case, and average-case runtimes. The runtime is defined as the number of iterations (i.e., the index where the key is found or \( n \) if not found).

\newpage

\section{Results}

\subsection{Worst-Case Runtime}
The worst-case runtime occurs when the search key is either found at the last index of the array or is not present. Below are the plots for the worst-case runtimes for each test character.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_e.pdf}
    \caption{Worst-case runtime for character `e`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_m.pdf}
    \caption{Worst-case runtime for character `m`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_Q.pdf}
    \caption{Worst-case runtime for character `Q`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_%.pdf}
    \caption{Worst-case runtime for character `%`.}
\end{figure}

\subsubsection{Interpretation}
From these plots, we can conjecture that the worst-case runtime grows linearly with the array size \( n \), as expected for a brute-force search algorithm, where every element in the array must be examined. This confirms that the worst-case time complexity is \( O(n) \).

\newpage

\subsection{Best-Case Runtime}
The best-case runtime occurs when the search key is found at the first index of the array. The following plots illustrate the best-case runtimes for each test character.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_e.pdf}
    \caption{Best-case runtime for character `e`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_m.pdf}
    \caption{Best-case runtime for character `m`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_Q.pdf}
    \caption{Best-case runtime for character `Q`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_%.pdf}
    \caption{Best-case runtime for character `%`.}
\end{figure}

\subsubsection{Interpretation}
The best-case runtime is constant and does not depend on the array size \( n \), as expected. The best-case time complexity is \( O(1) \).

\newpage

\subsection{Average-Case Runtime}
The average-case runtime is the mean of all runtimes for a given array size. Below are the average-case runtime plots for the four test characters.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_e.pdf}
    \caption{Average-case runtime for character `e`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_m.pdf}
    \caption{Average-case runtime for character `m`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_Q.pdf}
    \caption{Average-case runtime for character `Q`.}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{runtime_analysis_%.pdf}
    \caption{Average-case runtime for character `%`.}
\end{figure}

\subsubsection{Interpretation}
The average-case runtime is approximately half of the worst-case runtime, since on average the key is found around the middle of the array. This suggests an average-case time complexity of \( O(n) \), though with a smaller constant factor compared to the worst-case.

\newpage

\section{Conclusion}
This project provided an empirical analysis of a brute-force search algorithm. The worst-case, best-case, and average-case runtimes were measured for different search keys across varying array sizes. Our findings are consistent with the theoretical time complexities:

\begin{itemize}
    \item Worst-case runtime: \( O(n) \)
    \item Best-case runtime: \( O(1) \)
    \item Average-case runtime: \( O(n) \)
\end{itemize}

The results reinforce the understanding of brute-force search algorithms and their performance characteristics.

\section{Code Appendix}
The full implementation of the code can be found in the submitted `.zip` file. Below is a snippet of the core search algorithm.

\begin{verbatim}
# Brute-force search algorithm
def search_algorithm(arr, key):
    for i in range(len(arr)):
        if arr[i] == key:
            return i
    return len(arr)
\end{verbatim}

\end{document}
